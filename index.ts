//Typscript는 무엇인가?
// 타입스크립트는 MS에서 개발한 오픈소스프로그래밍 언어이며, 자바스크립트의 상위집합이다.
// 타입스크립트는 자바스크립트의 모든 기능을 포함하고 있으며, 정적 타입을 지원한다.

//장점
// 1. 정적 타입을 지원한다.
// 2. 객체지향 프로그래밍을 지원한다.
// 3. ES6의 최신 문법을 지원한다.
// 4. 모듈화를 지원한다.
// 5. 강력한 에디터 지원

//단점
// 1. 러닝커브가 있다.
// 2. 자바스크립트에 비해 무겁다.
// 3. 컴파일 단계가 필요하다.
// 4. 타입 정의가 필요하여 개발시간이 늘어난다.

// ------------------------------------------------------------------------------------------------------------------------------

//Typescript의 type alias와 interface의 차이점은 무엇인가?
type Point = {
  x: number
  y: number
}

type ID = string | number

type Person = {
  name: string
  age: number
}

// 인터셉션 타입
type Employee = Person & { jobTitle: string }

// 함수의 타입 정의
type AddFunc = (a: number, b: number) => number

// 제네릭 타입 정의
type Container<T> = { value: T }

// 유니온 타입 정의
type Result = 'success' | 'error'

// interface와의 차이점 중 하나는 type alias가 유니온 타입, 인터섹션 타입, 계산된 속성 등을 더 유연하게 다룰 수 있다는 점입니다.
// interface: interface는 implements 키워드를 사용하여 클래스에 직접 적용할 수 있습니다.

//유틸리티 타입
// Partial<T> 모든 속성을 선택적으로 변경
// Required<T> 모든 속성을 필수로 변경한다.
// Readonly<T> 읽기전용으로 변경.

// * Record<K,T> K의 모든 속성을 T로 변경
type PhoneNumbers = Record<string, string> // { [key: string]: string; }

// Pick<T,K> T에서 K만 선택
// Omit<T,K> T에서 K만 제거
// Exclude<T,U> T에서 U를 제거
// Extract<T,U> T에서 U만 추출

// ------------------------------------------------------------------------------------------------------------------------------

// 접근 제어자(Access Modifiers)는 클래스의 멤버(속성 또는 메서드)에 대한 접근을 제어하는 키워드입니다.
// TypeScript와 같은 객체지향 언어에서 사용되며, 주로 클래스의 캡슐화(encapsulation)를 강화하고 클래스의 내부 구현을 외부로부터 숨기는 데 사용됩니다.

// public: 어디서나 접근 가능
// protected: 클래스 내부 및 하위에서 접근가능
// private: 클래스 내부에서만 접근 가능
// readonly: 읽기 전용 속성을 만듭니다.

// ------------------------------------------------------------------------------------------------------------------------------

// useMemo와 useCallback의 차이점은 무엇인가?

// 반환 값:
// useCallback은 메모이제이션된 함수를 반환하고, useMemo는 메모이제이션된 값을 반환합니다.

// 사용 예시:
// useCallback은 주로 이벤트 핸들러 등 콜백 함수를 성능 최적화할 때 사용됩니다.
// useMemo는 계산 비용이 큰 값이나 객체를 캐싱하여 렌더링 시 성능을 향상시킬 때 사용됩니다.

// ------------------------------------------------------------------------------------------------------------------------------

// ESLint: 코드 품질 검사 및 스타일 가이드 적용.
// Prettier: 코드 자동 포맷팅 및 일관된 코드 스타일 유지.

// 동작 방식:
// ESLint: 규칙에 따라 코드를 분석하고, 오류 및 경고를 표시.
// Prettier: 코드를 완전히 재구성하여 일관된 스타일로 변환.

// 커스터마이징:
// ESLint: 프로젝트에 따라 규칙을 추가하거나 수정 가능.
// Prettier: 더 제한적이며, 일관된 코드 스타일을 강제함.

// 코드 일관성:

// 팀 전체에서 일관된 코드 스타일을 유지하여 가독성을 높입니다.

// 자동화:
// 코드 포맷팅을 자동화하여 개발자가 일일이 스타일을 지키지 않아도 됩니다.

// 버그 방지:
// ESLint는 코드 품질을 검사하여 잠재적인 버그를 사전에 방지합니다.
// 프로덕션 환경에서의 안정성:

// 코드 품질 및 스타일 규칙을 프로덕션 환경에서 강제하여 안정성을 확보합니다.
// 일반적으로 프로젝트에서는 ESLint와 Prettier를 함께 사용하여 코드 품질과 스타일을 효과적으로 관리합니다.

//TEST
// Generic
// 함수에 제너릭을 할당함으로써 타입을 추후의 설정할수있게 하는것

//유틸리티 타입은 무엇인가
// 유틸리티 타입은 총 8가지가 있으며
// Partial 요소를 옵셔널하게 만들어줌
// Required 요소를 필수로 만들어줌
// Readonly 읽기전용으로 만들어줌
// Record 키와 밸류를 받아서 객체로 만들어줌
// Pick 특정 요소만 뽑아서 만들어줌
// Omit 특정 요소만 제거해줌
// Exclude 특정 요소만 제거해줌
// Extract 특정 요소만 추출해줌

// 리액트의 훅으로는 useState, useEffect, useMemo, useCallback, useReducer 등등이 있습니다.
// react의 훅에서 useState는 값을 저장하고 값이 변경되었을시에 리렌더링을 해주는 훅입니다.
// useEffect는 컴포넌트가 렌더링 될때마다 특정 작업을 수행하도록 설정하는 훅입니다.
// useMemo는 특정 값이 바뀌었을때만 연산을 실행하고, 값이 바뀌지 않았다면 이전에 연산했던 결과를 다시 사용하는 훅이다.
// useCallback은 함수를 캐싱하는 훅이다.

// 리액트에서의 리렌더링을 최적화 할수있는 방법
// 1. shouldComponentUpdate 라이프사이클을 사용하여 리렌더링을 막을수있다.
// 2. React.memo를 사용하여 컴포넌트를 감싸서 props가 변경되었을때만 리렌더링을 하도록 설정할수있다.
// 3. useMemo를 사용하여 연산된 값을 재사용할수있다.
// 4. useCallback을 사용하여 함수를 캐싱할수있다.
// 5. React.lazy와 Suspense를 사용하여 컴포넌트를 비동기적으로 불러올수있다.
// 6. useState에서 불변성 데이터를 사용하여 리렌더링을 방지할수있습니다.
